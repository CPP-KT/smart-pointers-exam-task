# Smart Pointers

Существует различные способы реализовывать разделенное владение объектом.

## List Pointer 

В данном подзадании предлагается реализовать `List Pointer`. Его ключевая идея в том, что все разделяющие владение объекты провязываются в список, а когда удаляется последний объект из списка -- удаляется и сам хранимый объект.

Важной особенностью этого умного указателя является то, что он никогда не выделяет динамическую память (такое может делать только `makeListPtr` при создании объекта).

## Non Dangling Pointer

Также необходимо реализовать умный указатель `Non Dangling Pointer`. Его суть заключается в том, что он ведет себя как обычный указатель, но при удалении одного из указателей на объект все остальные становятся эквивалентны `nullptr`.

Пример использования:

```c++

class A { 
  // ... 
};

// ...

NoDanglePtr<A> p(new A());
auto q = p;

p->doSmth();
delete p;
// here references to q should evaluate to nullptr

```

## Тесты

В репозитории дан интерфейс `ListPtr`, `NoDanglePtr`, а также тесты к `ListPtr`. Тесты к `NoDanglePtr` нужно реализовать самостоятельно, при этом можно использовать существующие в репозитории технические классы (e.g. `TestObject`).

## Дополнительные условия

При решении задания обратите внимание на:
- расстановку `noexcept` во всех необходимых местах;
- пояснение всех возможных трейд-оффов, которые встречаются при реализации;
- можно считать, что умные указатели не обязаны работать в многопоточной среде;
- в комментарии к Pull Request при сдаче тезисно опишите преимущества и недостатки `List Pointer` по сравнению с `Shared Pointer`.

> NOTE: обратите внимание, что шаблон репозитория поменялся по сравнению с предыдущими заданиями, актуальную информацию можно найти на [сайте курса](https://cpp-kt.github.io/course/ide.html)
